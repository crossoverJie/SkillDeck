import SwiftUI
import AppKit

/// AppDelegate handles app-level lifecycle events
/// In SwiftUI apps, use @NSApplicationDelegateAdaptor to bridge with it
/// Main purpose: When launching via `swift run`, macOS doesn't automatically bring the app window to the foreground (because it's not a .app bundle)
class AppDelegate: NSObject, NSApplicationDelegate {
    func applicationWillFinishLaunching(_ notification: Notification) {
        // setActivationPolicy(.regular) tells macOS: this is a normal GUI app
        // Without this line, the bare executable launched from command line is treated as a "background process",
        // won't show an icon in the Dock, and won't create windows
        // .regular = Normal GUI app (with Dock icon and menu bar)
        // .accessory = Accessory app (menu bar only, no Dock icon)
        // .prohibited = Pure background process (no UI)
        NSApplication.shared.setActivationPolicy(.regular)
    }

    func applicationDidFinishLaunching(_ notification: Notification) {
        // Activate app to foreground to ensure window is visible
        NSApplication.shared.activate(ignoringOtherApps: true)

        // Set app icon: The bare executable launched via swift run has no .app bundle,
        // so macOS won't automatically read CFBundleIconFile from Info.plist.
        // Need to manually load .icns file from SPM's Bundle.module and set it to NSApplication.
        // Bundle.module is a property auto-generated by SPM, pointing to the resource bundle packaged at compile time
        // (similar to Android's R.drawable or Java's ClassLoader.getResource)
        if let iconURL = Bundle.module.url(forResource: "AppIcon", withExtension: "icns") {
            // NSImage(contentsOf:) loads image from file URL, supports .icns multi-resolution format
            NSApplication.shared.applicationIconImage = NSImage(contentsOf: iconURL)
        }
    }
}

/// @main marks the app's entry point (similar to Java's public static void main or Go's func main())
///
/// SwiftUI's App protocol defines the entire app structure:
/// - body property returns the app's Scene (window)
/// - WindowGroup creates a multi-window scene (macOS supports multiple windows)
///
/// @State is SwiftUI's state management property wrapper:
/// - When a value marked with @State changes, SwiftUI automatically re-renders the related View
/// - Similar to React's useState or Vue's ref()
@main
struct SkillDeckApp: App {

    /// SkillManager is the app's core state manager
    /// Using @State lets SwiftUI manage its lifecycle
    @State private var skillManager = SkillManager()

    /// NSApplicationDelegateAdaptor bridges SwiftUI with traditional AppKit lifecycle
    /// Through AppDelegate we can perform AppKit-level operations at app launch
    /// Used here to solve the issue of windows not auto-activating when launched from command line
    @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate

    var body: some Scene {
        // WindowGroup creates the main window
        WindowGroup {
            ContentView()
                // .environment injects skillManager into the entire View hierarchy
                // All child views can access it via @Environment
                // Similar to React's Context Provider or Android's dependency injection
                .environment(skillManager)
        }
        // Set the window's default size
        .defaultSize(width: 1000, height: 700)

        // Settings scene: macOS app's "Preferences" window
        // Users can open it with Cmd+,
        // .environment(skillManager) injects SkillManager,
        // allowing AboutSettingsView to access update state via @Environment
        // Settings scene and WindowGroup are independent View hierarchies, requiring separate environment injection
        Settings {
            SettingsView()
                .environment(skillManager)
        }
    }
}
